{% comment %}
  Filtros simplificados: 4 dropdowns horizontales
  - Categor√≠as
  - Color
  - Talla (usando metafield custom.talla_estandar)
  - Precio
{% endcomment %}

<div class="collection-filters-simple">
  <div class="container container-v1">
    <div class="row">
      <div class="col-12">
        <div class="filters-row d-flex flex-wrap">
          
          {% comment %} Filtro de Categor√≠as {% endcomment %}
          <div class="filter-dropdown-wrapper">
            <select class="filter-dropdown" id="filter-category" data-filter="category">
              <option value="">CATEGOR√çAS</option>
              {% if settings.widget_cate_menu != blank %}
                {% for link in linklists[settings.widget_cate_menu].links %}
                  <option value="{{ link.url }}" {% if collection.url == link.url %}selected{% endif %}>
                    {{ link.title | split: '[' | first }}
                  </option>
                {% endfor %}
              {% else %}
                {% comment %} Fallback: usar todas las colecciones principales {% endcomment %}
                {% for collection_item in collections %}
                  {% unless collection_item.handle == 'all' or collection_item.handle == 'frontpage' %}
                    <option value="{{ collection_item.url }}" {% if collection.url == collection_item.url %}selected{% endif %}>
                      {{ collection_item.title }}
                    </option>
                  {% endunless %}
                {% endfor %}
              {% endif %}
            </select>
          </div>

          {% comment %} Filtro de Color - Din√°mico desde opci√≥n de variante {% endcomment %}
          <div class="filter-dropdown-wrapper">
            <select class="filter-dropdown" id="filter-color" data-filter="color">
              <option value="">COLOR</option>
              {% comment %} Los colores se poblar√°n din√°micamente con JavaScript seg√∫n productos visibles {% endcomment %}
            </select>
          </div>

          {% comment %} Filtro de Talla (usando metafield custom.talla_estandar de producto) {% endcomment %}
          <div class="filter-dropdown-wrapper">
            <select class="filter-dropdown" id="filter-size" data-filter="size">
              <option value="">TALLA</option>
              {% comment %} Las tallas se poblar√°n din√°micamente con JavaScript seg√∫n productos visibles {% endcomment %}
            </select>
          </div>

          {% comment %} Filtro de Precio - Rangos fijos: 0-50, 50-150, 150+ {% endcomment %}
          <div class="filter-dropdown-wrapper">
            <select class="filter-dropdown" id="filter-price" data-filter="price">
              <option value="">PRECIO</option>
              <option value="0-50" {% if current_tags contains 'price-0-50' or current_tags contains '0-50' %}selected{% endif %}>0 - 50</option>
              <option value="50-150" {% if current_tags contains 'price-50-150' or current_tags contains '50-150' %}selected{% endif %}>50 - 150</option>
              <option value="150+" {% if current_tags contains 'price-150+' or current_tags contains '150+' %}selected{% endif %}>150+</option>
            </select>
          </div>

        </div>
      </div>
    </div>
  </div>
</div>

<style>
  .collection-filters-simple {
    margin: 20px 0;
  padding: 0;
  }
  
  .filters-row {
    gap: 15px;
    margin-bottom: 0;
  }
  
  .filter-dropdown-wrapper {
    flex: 1;
    min-width: 150px;
  }
  
  .filter-dropdown {
    width: 100%;
    padding: 12px 40px 12px 15px;
    border: 1px solid #000;
    background: #fff;
    font-size: 14px;
    font-weight: 400;
    color: #000;
    appearance: none;
    -webkit-appearance: none;
    -moz-appearance: none;
    background-image: url("data:image/svg+xml,%3Csvg xmlns='http://www.w3.org/2000/svg' width='12' height='12' viewBox='0 0 12 12'%3E%3Cpath fill='%23000' d='M6 9L1 4h10z'/%3E%3C/svg%3E");
    background-repeat: no-repeat;
    background-position: right 15px center;
    background-size: 12px;
    cursor: pointer;
    transition: all 0.3s ease;
  }
  
  .filter-dropdown:hover {
    border-color: #333;
  }
  
  .filter-dropdown:focus {
    outline: none;
    border-color: #000;
  }
  
  /* Animaciones para filtrado */
  .product-item-wrapper {
    transition: opacity 0.3s ease, transform 0.3s ease;
  }
  
  #products-container.filtering .product-item-wrapper {
    transform: scale(0.98);
  }
  
  /* Responsive */
  @media (max-width: 991px) {
    .filters-row {
      gap: 10px;
    }
    
    .filter-dropdown-wrapper {
      flex: 0 0 calc(50% - 5px);
      min-width: calc(50% - 5px);
      max-width: calc(50% - 5px);
    }
    
    .filter-dropdown {
      font-size: 13px;
      padding: 10px 35px 10px 12px;
    }
  }
  
  @media (max-width: 575px) {
    .collection-filters-simple {
      margin: 15px 0;
    }
    
    .filters-row {
      gap: 10px;
    }
    
    .filter-dropdown-wrapper {
      flex: 0 0 100%;
      min-width: 100%;
      max-width: 100%;
    }
    
    .filter-dropdown {
      font-size: 13px;
      padding: 10px 35px 10px 12px;
    }
  }
</style>

<script>
  (function() {
    // Funci√≥n helper para simular handleize de Liquid
    function handleize(str) {
      if (!str) return '';
      return str.toString()
        .toLowerCase()
        .trim()
        .replace(/[^\w\s-]/g, '') // Eliminar caracteres especiales
        .replace(/[\s_-]+/g, '-') // Reemplazar espacios, guiones bajos y guiones con un solo guion
        .replace(/^-+|-+$/g, ''); // Eliminar guiones al inicio y final
    }
    
    // Inicializar filtros cuando el DOM est√© listo
    if (document.readyState === 'loading') {
      document.addEventListener('DOMContentLoaded', initFilters);
    } else {
      initFilters();
    }
    
    function initFilters() {
      console.log('Inicializando filtros...');
      
      // Verificar que los elementos existan
      const productsContainer = document.getElementById('products-container');
      if (!productsContainer) {
        console.error('‚ùå NO se encontr√≥ el contenedor #products-container');
        return;
      }
      
      const filterDropdowns = document.querySelectorAll('.filter-dropdown');
      if (filterDropdowns.length === 0) {
        console.error('‚ùå NO se encontraron dropdowns de filtros');
        return;
      }
      
      filterDropdowns.forEach(function(dropdown) {
        dropdown.addEventListener('change', function() {
          console.log('Filtro cambiado:', dropdown.id, '=', dropdown.value);
          
          // Si cambia el filtro de color, resetear talla y precio
          if (dropdown.id === 'filter-color') {
            const sizeFilter = document.getElementById('filter-size');
            const priceFilter = document.getElementById('filter-price');
            if (sizeFilter) sizeFilter.value = '';
            if (priceFilter) priceFilter.value = '';
          }
          
          // Si cambia el filtro de talla, resetear precio
          if (dropdown.id === 'filter-size') {
            const priceFilter = document.getElementById('filter-price');
            if (priceFilter) priceFilter.value = '';
          }
          
          // Actualizar dropdowns seg√∫n jerarqu√≠a y luego aplicar filtros
          updateFilterDropdowns();
          applyFilters();
        });
      });
      
      // Asegurar que todos los productos sean visibles inicialmente
      try {
        const productWrappers = document.querySelectorAll('.product-item-wrapper');
        console.log('Productos encontrados para filtrado:', productWrappers.length);
        
        if (productWrappers.length === 0) {
          console.error('‚ùå NO se encontraron productos con clase .product-item-wrapper');
          console.error('   Buscando alternativas...');
          // Intentar buscar productos con otras clases comunes
          const altProducts = document.querySelectorAll('.product-item, .product, [data-product-id]');
          console.log('   Productos encontrados con otras clases:', altProducts.length);
          if (altProducts.length > 0) {
            console.warn('   ‚ö†Ô∏è Los productos no tienen la clase .product-item-wrapper');
            console.warn('   Esto impedir√° que los filtros funcionen correctamente');
          }
          return;
        }
        
        productWrappers.forEach(function(wrapper, index) {
          try {
            wrapper.style.display = '';
            wrapper.style.opacity = '1';
            
            // Debug: verificar data-attributes
            const colors = wrapper.getAttribute('data-product-colors');
            const colorsNames = wrapper.getAttribute('data-product-colors-names');
            const sizes = wrapper.getAttribute('data-product-sizes');
            const sizesNames = wrapper.getAttribute('data-product-sizes-names');
            const price = wrapper.getAttribute('data-product-price');
            const productId = wrapper.getAttribute('data-product-id');
            
            const debugColorIndex = wrapper.getAttribute('data-debug-color-index');
            const debugSizeIndex = wrapper.getAttribute('data-debug-size-index');
            const debugHasTalla = wrapper.getAttribute('data-debug-has-talla');
            const debugOptions = wrapper.getAttribute('data-debug-options');
            const debugVariantOptions = wrapper.getAttribute('data-debug-variant-options');
            
            // Verificar HTML completo del elemento para debug
            const outerHTML = wrapper.outerHTML ? wrapper.outerHTML.substring(0, 500) : '(no disponible)';
            
            console.log('=== Producto #' + (index + 1) + ' (ID: ' + (productId || 'sin ID') + ') ===');
            console.log('  Opciones disponibles:', debugOptions || '(no encontrado)');
            console.log('  Valores de variante (ejemplo):', debugVariantOptions || '(no encontrado)');
            console.log('  data-product-colors:', colors || '(vac√≠o)');
            console.log('  data-product-colors-names:', colorsNames || '(vac√≠o)');
            console.log('  data-product-sizes:', sizes || '(vac√≠o)');
            console.log('  data-product-sizes-names:', sizesNames || '(vac√≠o)');
            console.log('  data-product-price:', price || '(vac√≠o)');
            console.log('  DEBUG - color_option_index:', debugColorIndex || '(no encontrado)');
            console.log('  DEBUG - size_option_index:', debugSizeIndex || '(no encontrado)');
            console.log('  DEBUG - tiene metafield talla:', debugHasTalla || '(no encontrado)');
            
            // Debug espec√≠fico para tallas
            if (!sizes || sizes.trim() === '') {
              console.warn('  ‚ö†Ô∏è PROBLEMA: Este producto NO tiene tallas extra√≠das');
              console.warn('     Opciones del producto:', debugOptions);
              console.warn('     Valores de variante:', debugVariantOptions);
              console.warn('     size_option_index:', debugSizeIndex);
              if (debugSizeIndex === '-1' || debugSizeIndex === null || debugSizeIndex === '') {
                console.warn('     ‚Üí No se encontr√≥ una opci√≥n llamada "Size", "Talla" o "Tama√±o"');
                console.warn('     ‚Üí Intentando usar la opci√≥n que NO es color como fallback');
              }
            }
            
            console.log('  HTML (primeros 500 chars):', outerHTML);
            
            // Verificar si el elemento tiene los atributos en el HTML
            if (!colors && !sizes) {
              console.warn('  ‚ö†Ô∏è Este producto NO tiene data-attributes de color ni talla');
              if (debugColorIndex === '-1' || debugColorIndex === null || debugColorIndex === '') {
                console.warn('    ‚Üí Raz√≥n Color: No se encontr√≥ opci√≥n "Color" en las variantes (index: ' + debugColorIndex + ')');
              }
              if ((debugSizeIndex === '-1' || debugSizeIndex === null || debugSizeIndex === '') && (debugHasTalla === 'no' || debugHasTalla === null || debugHasTalla === '')) {
                console.warn('    ‚Üí Raz√≥n Talla: No se encontr√≥ opci√≥n "Size/Talla" en las variantes (index: ' + debugSizeIndex + ') y no tiene metafield custom.talla_estandar');
              } else if (debugSizeIndex === '-1' || debugSizeIndex === null || debugSizeIndex === '') {
                console.warn('    ‚Üí Raz√≥n Talla: No se encontr√≥ opci√≥n "Size/Talla" en las variantes (index: ' + debugSizeIndex + ')');
              }
            } else {
              console.log('  ‚úÖ Este producto S√ç tiene data-attributes');
            }
          } catch (err) {
            console.error('Error procesando producto #' + (index + 1) + ':', err);
          }
        });
      } catch (err) {
        console.error('Error en initFilters al procesar productos:', err);
      }
      
      // Poblar dropdowns inicialmente despu√©s de un peque√±o delay para asegurar que el DOM est√© listo
      setTimeout(function() {
        console.log('Poblando dropdowns inicialmente...');
        updateFilterDropdowns();
        
        // Mostrar resumen de diagn√≥stico
        const allWrappers = document.querySelectorAll('.product-item-wrapper');
        let productsWithColors = 0;
        let productsWithSizes = 0;
        let productsWithPrice = 0;
        
        allWrappers.forEach(function(wrapper) {
          if (wrapper.getAttribute('data-product-colors') && wrapper.getAttribute('data-product-colors').trim() !== '') {
            productsWithColors++;
          }
          if (wrapper.getAttribute('data-product-sizes') && wrapper.getAttribute('data-product-sizes').trim() !== '') {
            productsWithSizes++;
          }
          if (wrapper.getAttribute('data-product-price') && wrapper.getAttribute('data-product-price').trim() !== '') {
            productsWithPrice++;
          }
        });
        
        console.log('=== RESUMEN DE DIAGN√ìSTICO ===');
        console.log('Total de productos:', allWrappers.length);
        console.log('Productos con colores:', productsWithColors, '/', allWrappers.length);
        console.log('Productos con tallas:', productsWithSizes, '/', allWrappers.length);
        console.log('Productos con precio:', productsWithPrice, '/', allWrappers.length);
        
        if (productsWithColors === 0) {
          console.error('‚ùå PROBLEMA: Ning√∫n producto tiene datos de color');
          console.error('   ‚Üí Verifica que los productos tengan una opci√≥n de variante llamada "Color" o "Colour"');
        }
        if (productsWithSizes === 0) {
          console.error('‚ùå PROBLEMA: Ning√∫n producto tiene datos de talla');
          console.error('   ‚Üí Verifica que los productos tengan:');
          console.error('      1. Una opci√≥n de variante llamada "Size", "Talla" o "Tama√±o"');
          console.error('      2. O el metafield custom.talla_estandar configurado');
        }
        if (productsWithPrice === 0) {
          console.error('‚ùå PROBLEMA: Ning√∫n producto tiene datos de precio');
          console.error('   ‚Üí Verifica que los productos tengan precio configurado');
        } else {
          // Mostrar rango de precios encontrados
          let minPrice = Infinity;
          let maxPrice = -Infinity;
          allWrappers.forEach(function(wrapper) {
            const priceAttr = wrapper.getAttribute('data-product-price');
            if (priceAttr && priceAttr.trim() !== '') {
              const price = parseFloat(priceAttr.toString().trim().replace(/[^\d.]/g, ''));
              if (!isNaN(price)) {
                if (price < minPrice) minPrice = price;
                if (price > maxPrice) maxPrice = price;
              }
            }
          });
          if (minPrice !== Infinity && maxPrice !== -Infinity) {
            console.log('üí∞ Rango de precios encontrado:', minPrice, '-', maxPrice);
            console.log('   Filtros disponibles: 0-50, 50-150, 150+');
          }
        }
      }, 200);
      
      // Restaurar valores desde URL si existen
      restoreFiltersFromURL();
    }
    
    function restoreFiltersFromURL() {
      const urlParams = new URLSearchParams(window.location.search);
      const colorFilter = document.getElementById('filter-color');
      const sizeFilter = document.getElementById('filter-size');
      const priceFilter = document.getElementById('filter-price');
      
      // Restaurar desde par√°metros individuales (nuevo formato)
      const color = urlParams.get('color');
      const size = urlParams.get('size');
      const price = urlParams.get('price');
      
      if (color && colorFilter && colorFilter.querySelector('option[value="' + decodeURIComponent(color) + '"]')) {
        colorFilter.value = decodeURIComponent(color);
      }
      
      if (size && sizeFilter && sizeFilter.querySelector('option[value="' + decodeURIComponent(size) + '"]')) {
        sizeFilter.value = decodeURIComponent(size);
      }
      
      if (price && priceFilter) {
        const decodedPrice = decodeURIComponent(price);
        if (decodedPrice === '0-50' || decodedPrice === '50-150' || decodedPrice === '150+') {
          priceFilter.value = decodedPrice;
        }
      }
      
      // Tambi√©n soportar formato antiguo con constraint (para compatibilidad)
      const constraint = urlParams.get('constraint');
      if (constraint && (!color && !size && !price)) {
        const tags = constraint.split('+');
        tags.forEach(function(tag) {
          const decodedTag = decodeURIComponent(tag);
          
          // Manejar rangos de precio
          if (decodedTag === 'price-0-50' && priceFilter) {
            priceFilter.value = '0-50';
          } else if (decodedTag === 'price-50-150' && priceFilter) {
            priceFilter.value = '50-150';
          } else if (decodedTag === 'price-150+' && priceFilter) {
            priceFilter.value = '150+';
          }
          // Intentar asignar a filtros de color y talla
          else if (colorFilter && colorFilter.querySelector('option[value="' + decodedTag + '"]')) {
            colorFilter.value = decodedTag;
          } else if (sizeFilter && sizeFilter.querySelector('option[value="' + decodedTag + '"]')) {
            sizeFilter.value = decodedTag;
          }
        });
      }
      
      // Aplicar filtros despu√©s de restaurar
      if (color || size || price || constraint) {
        setTimeout(function() {
          // Primero actualizar dropdowns, luego aplicar filtros
          updateFilterDropdowns();
          applyFilters();
        }, 100);
      } else {
        // Si no hay filtros en URL, poblar dropdowns inicialmente
        setTimeout(function() {
          updateFilterDropdowns();
        }, 100);
      }
    }
    
    // Funci√≥n para recopilar colores y tallas de productos visibles
    function getVisibleProductsData() {
      const productWrappers = document.querySelectorAll('.product-item-wrapper');
      const colorsMap = {}; // { handle: nombre_original }
      const sizesMap = {}; // { handle: nombre_original }
      
      productWrappers.forEach(function(wrapper) {
        // Solo considerar productos que est√°n visibles (no ocultos por display:none)
        const isVisible = wrapper.offsetParent !== null || 
                         (wrapper.style.display !== 'none' && wrapper.style.opacity !== '0');
        
        if (!isVisible) return;
        
        // Recopilar colores
        const productColors = wrapper.getAttribute('data-product-colors');
        if (productColors && productColors.trim() !== '') {
          const colors = productColors.split(',').map(function(c) { 
            return handleize(c.trim()); 
          }).filter(function(c) { return c !== ''; });
          
          // Necesitamos obtener el nombre original del color
          // Como solo tenemos el handle en data-attribute, usaremos el handle como nombre
          // (En un caso ideal, tendr√≠amos data-product-colors-names, pero por ahora usamos handle)
          colors.forEach(function(colorHandle) {
            if (!colorsMap[colorHandle]) {
              // Convertir handle a nombre legible (capitalizar primera letra de cada palabra)
              const colorName = colorHandle.split('-').map(function(word) {
                return word.charAt(0).toUpperCase() + word.slice(1);
              }).join(' ');
              colorsMap[colorHandle] = colorName;
            }
          });
        }
        
        // Recopilar tallas
        const productSizes = wrapper.getAttribute('data-product-sizes');
        if (productSizes && productSizes.trim() !== '') {
          const sizes = productSizes.split(',').map(function(s) { 
            return handleize(s.trim()); 
          }).filter(function(s) { return s !== ''; });
          
          sizes.forEach(function(sizeHandle) {
            if (!sizesMap[sizeHandle]) {
              // Convertir handle a nombre legible (may√∫sculas)
              const sizeName = sizeHandle.toUpperCase();
              sizesMap[sizeHandle] = sizeName;
            }
          });
        }
      });
      
      return { colors: colorsMap, sizes: sizesMap };
    }
    
    // Funci√≥n para actualizar dropdowns seg√∫n productos visibles
    function updateFilterDropdowns() {
      console.log('Actualizando dropdowns de filtros...');
      const colorFilter = document.getElementById('filter-color');
      const sizeFilter = document.getElementById('filter-size');
      const categoryFilter = document.getElementById('filter-category');
      const selectedColor = colorFilter ? colorFilter.value : '';
      const selectedSize = sizeFilter ? sizeFilter.value : '';
      
      // Obtener productos visibles (sin filtros de color/talla aplicados a√∫n)
      // Primero aplicar solo filtros anteriores en la jerarqu√≠a
      const tempProductWrappers = document.querySelectorAll('.product-item-wrapper');
      console.log('Total de productos encontrados:', tempProductWrappers.length);
      
      // Determinar qu√© productos considerar seg√∫n jerarqu√≠a
      // Si hay color seleccionado, solo considerar productos con ese color
      // Si hay talla seleccionada, solo considerar productos con esa talla (despu√©s de color)
      
      // Para color: considerar todos los productos inicialmente, o solo los que pasaron filtros anteriores
      let productsToConsider = Array.from(tempProductWrappers);
      
      // Si hay color seleccionado, filtrar por color primero
      if (selectedColor && selectedColor.trim() !== '') {
        productsToConsider = productsToConsider.filter(function(wrapper) {
          const productColors = wrapper.getAttribute('data-product-colors');
          if (!productColors || productColors.trim() === '') return false;
          const colors = productColors.split(',').map(function(c) { 
            return handleize(c.trim()); 
          }).filter(function(c) { return c !== ''; });
          const selectedColorHandle = handleize(selectedColor.trim());
          return colors.indexOf(selectedColorHandle) !== -1;
        });
      }
      
      // Recopilar colores de productos considerados (sin filtro de color aplicado a√∫n)
      const allColorsMap = {};
      const allSizesMap = {};
      
      // Primero, recopilar de TODOS los productos para el dropdown de color
      tempProductWrappers.forEach(function(wrapper) {
        const productColors = wrapper.getAttribute('data-product-colors');
        const productColorsNames = wrapper.getAttribute('data-product-colors-names');
        if (productColors && productColors.trim() !== '') {
          const colors = productColors.split(',').map(function(c) { 
            return handleize(c.trim()); 
          }).filter(function(c) { return c !== ''; });
          const colorNames = productColorsNames ? productColorsNames.split('|||') : [];
          
          colors.forEach(function(colorHandle, index) {
            if (!allColorsMap[colorHandle]) {
              // Usar nombre original si est√° disponible, sino convertir handle
              const colorName = colorNames[index] || colorHandle.split('-').map(function(word) {
                return word.charAt(0).toUpperCase() + word.slice(1);
              }).join(' ');
              allColorsMap[colorHandle] = colorName;
            }
          });
        }
      });
      
      console.log('Colores encontrados:', Object.keys(allColorsMap).length, allColorsMap);
      
      if (Object.keys(allColorsMap).length === 0) {
        console.warn('‚ö†Ô∏è No se encontraron colores en los productos');
        console.warn('   Posibles causas:');
        console.warn('   1. Los productos no tienen una opci√≥n de variante llamada "Color" o "Colour"');
        console.warn('   2. Las variantes no tienen valores en la opci√≥n de color');
        console.warn('   3. Los productos no tienen variantes');
      }
      
      // Para talla: recopilar solo de productos que pasaron el filtro de color (si hay)
      productsToConsider.forEach(function(wrapper) {
        const productSizes = wrapper.getAttribute('data-product-sizes');
        const productSizesNames = wrapper.getAttribute('data-product-sizes-names');
        if (productSizes && productSizes.trim() !== '') {
          const sizes = productSizes.split(',').map(function(s) { 
            return handleize(s.trim()); 
          }).filter(function(s) { return s !== ''; });
          const sizeNames = productSizesNames ? productSizesNames.split('|||') : [];
          
          sizes.forEach(function(sizeHandle, index) {
            if (!allSizesMap[sizeHandle]) {
              // Usar nombre original si est√° disponible, sino convertir handle
              const sizeName = sizeNames[index] || sizeHandle.toUpperCase();
              allSizesMap[sizeHandle] = sizeName;
            }
          });
        }
      });
      
      console.log('Tallas encontradas:', Object.keys(allSizesMap).length, allSizesMap);
      
      if (Object.keys(allSizesMap).length === 0) {
        console.warn('‚ö†Ô∏è No se encontraron tallas en los productos');
        console.warn('   Posibles causas:');
        console.warn('   1. Los productos no tienen una opci√≥n de variante llamada "Size", "Talla" o "Tama√±o"');
        console.warn('   2. Los productos no tienen el metafield custom.talla_estandar configurado');
        console.warn('   3. Las variantes no tienen valores en la opci√≥n de talla');
        console.warn('   4. Los productos no tienen variantes');
      }
      
      // Actualizar dropdown de color (siempre muestra todos los colores disponibles)
      if (colorFilter) {
        const currentValue = colorFilter.value;
        colorFilter.innerHTML = '<option value="">COLOR</option>';
        
        const sortedColors = Object.keys(allColorsMap).sort();
        console.log('Agregando', sortedColors.length, 'colores al dropdown');
        sortedColors.forEach(function(colorHandle) {
          const option = document.createElement('option');
          option.value = colorHandle;
          option.textContent = allColorsMap[colorHandle];
          if (colorHandle === currentValue) {
            option.selected = true;
          }
          colorFilter.appendChild(option);
        });
      } else {
        console.error('No se encontr√≥ el dropdown de color');
      }
      
      // Actualizar dropdown de talla (solo muestra tallas de productos que pasaron filtros anteriores)
      if (sizeFilter) {
        const currentValue = sizeFilter.value;
        sizeFilter.innerHTML = '<option value="">TALLA</option>';
        
        const sortedSizes = Object.keys(allSizesMap).sort();
        console.log('Agregando', sortedSizes.length, 'tallas al dropdown');
        sortedSizes.forEach(function(sizeHandle) {
          const option = document.createElement('option');
          option.value = sizeHandle;
          option.textContent = allSizesMap[sizeHandle];
          if (sizeHandle === currentValue) {
            option.selected = true;
          }
          sizeFilter.appendChild(option);
        });
      } else {
        console.error('No se encontr√≥ el dropdown de talla');
      }
    }
    
    function applyFilters() {
      // Obtener valores de los filtros
      const categoryFilter = document.getElementById('filter-category');
      const colorFilter = document.getElementById('filter-color');
      const sizeFilter = document.getElementById('filter-size');
      const priceFilter = document.getElementById('filter-price');
      
      // Si se selecciona una categor√≠a, redirigir limpiando filtros de la URL
      if (categoryFilter && categoryFilter.value) {
        // Limpiar par√°metros de filtros de la URL antes de redirigir
        const categoryUrl = categoryFilter.value.split('?')[0]; // Obtener URL sin par√°metros
        window.location.href = categoryUrl;
        return;
      }
      
      // Si se vuelve a "CATEGOR√çAS" (valor vac√≠o), resetear otros filtros
      if (categoryFilter && !categoryFilter.value) {
        if (colorFilter) colorFilter.value = '';
        if (sizeFilter) sizeFilter.value = '';
        if (priceFilter) priceFilter.value = '';
      }
      
      // Obtener valores de filtros
      const selectedColor = colorFilter ? colorFilter.value : '';
      const selectedSize = sizeFilter ? sizeFilter.value : '';
      const selectedPrice = priceFilter ? priceFilter.value : '';
      
      console.log('Aplicando filtros:', {
        color: selectedColor,
        size: selectedSize,
        price: selectedPrice
      });
      
      // Filtrar productos del lado del cliente
      const productWrappers = document.querySelectorAll('.product-item-wrapper');
      console.log('Productos encontrados:', productWrappers.length);
      let visibleCount = 0;
      
      // Agregar clase de transici√≥n
      if (productWrappers.length > 0) {
        productWrappers[0].parentElement.classList.add('filtering');
      }
      
      productWrappers.forEach(function(wrapper) {
        let showProduct = true;
        
        // Filtro por color
        if (selectedColor && selectedColor.trim() !== '') {
          const productColors = wrapper.getAttribute('data-product-colors');
          if (productColors && productColors.trim() !== '') {
            const colors = productColors.split(',').map(function(c) { 
              return handleize(c.trim()); 
            }).filter(function(c) { return c !== ''; });
            const selectedColorHandle = handleize(selectedColor.trim());
            let colorMatch = false;
            for (let i = 0; i < colors.length; i++) {
              if (colors[i] === selectedColorHandle) {
                colorMatch = true;
                break;
              }
            }
            if (!colorMatch) {
              showProduct = false;
            }
          } else {
            showProduct = false;
          }
        }
        
        // Filtro por talla
        if (showProduct && selectedSize && selectedSize.trim() !== '') {
          const productSizes = wrapper.getAttribute('data-product-sizes');
          if (productSizes && productSizes.trim() !== '') {
            const sizes = productSizes.split(',').map(function(s) { 
              return handleize(s.trim()); 
            }).filter(function(s) { return s !== ''; });
            const selectedSizeHandle = handleize(selectedSize.trim());
            let sizeMatch = false;
            for (let i = 0; i < sizes.length; i++) {
              if (sizes[i] === selectedSizeHandle) {
                sizeMatch = true;
                break;
              }
            }
            if (!sizeMatch) {
              showProduct = false;
            }
          } else {
            showProduct = false;
          }
        }
        
        // Filtro por precio
        if (showProduct && selectedPrice && selectedPrice.trim() !== '') {
          const productPriceAttr = wrapper.getAttribute('data-product-price');
          
          // Debug: verificar que el atributo existe
          if (!productPriceAttr || productPriceAttr.trim() === '') {
            console.warn('‚ö†Ô∏è Producto sin data-product-price:', wrapper);
            showProduct = false;
          } else {
            // Limpiar el valor de posibles caracteres no num√©ricos y convertir a n√∫mero
            let priceStr = productPriceAttr.toString().trim();
            // Reemplazar comas por puntos para formato decimal
            priceStr = priceStr.replace(/,/g, '.');
            // Eliminar todo excepto n√∫meros y punto decimal
            priceStr = priceStr.replace(/[^\d.]/g, '');
            const productPrice = parseFloat(priceStr);
            
            // Verificar que el precio sea un n√∫mero v√°lido
            if (isNaN(productPrice) || productPrice < 0) {
              console.warn('‚ùå Precio inv√°lido para producto:', productPriceAttr, '->', productPrice);
              console.warn('   Valor original:', productPriceAttr);
              console.warn('   Valor procesado:', priceStr);
              showProduct = false;
            } else {
              let priceMatch = false;
              const priceValue = productPrice;
              
              // Aplicar filtro seg√∫n rango seleccionado
              if (selectedPrice === '0-50') {
                priceMatch = priceValue >= 0 && priceValue < 50;
              } else if (selectedPrice === '50-150') {
                priceMatch = priceValue >= 50 && priceValue <= 150;
              } else if (selectedPrice === '150+') {
                priceMatch = priceValue >= 150;
              } else {
                console.warn('‚ö†Ô∏è Rango de precio desconocido:', selectedPrice);
                priceMatch = false;
              }
              
              // Debug solo si hay problema
              if (!priceMatch && visibleCount < 5) {
                console.log('üîç Filtro precio - Producto ID:', productId, '| Precio:', priceValue, '| Rango:', selectedPrice, '| No coincide');
              }
              
              if (!priceMatch) {
                showProduct = false;
              }
            }
          }
        }
        
        // Mostrar u ocultar producto con animaci√≥n
        if (showProduct) {
          wrapper.style.display = '';
          wrapper.style.opacity = '1';
          visibleCount++;
        } else {
          wrapper.style.opacity = '0';
          setTimeout(function() {
            wrapper.style.display = 'none';
          }, 200);
        }
      });
      
      // Remover clase de transici√≥n despu√©s de animaci√≥n
      setTimeout(function() {
        const container = document.getElementById('products-container');
        if (container) {
          container.classList.remove('filtering');
        }
      }, 300);
      
      // Mostrar mensaje si no hay productos
      const productsContainer = document.getElementById('products-container');
      let noResultsMsg = document.querySelector('.no-results-message');
      
      if (visibleCount === 0 && productWrappers.length > 0) {
        if (!noResultsMsg) {
          noResultsMsg = document.createElement('div');
          noResultsMsg.className = 'col-12 text-center no-results-message';
          noResultsMsg.style.padding = '40px 20px';
          noResultsMsg.innerHTML = '<p style="font-size: 16px; color: #666;">No se encontraron productos con los filtros seleccionados.</p>';
          if (productsContainer) {
            productsContainer.appendChild(noResultsMsg);
          }
        }
        noResultsMsg.style.display = 'block';
      } else if (noResultsMsg) {
        noResultsMsg.style.display = 'none';
      }
      
      // Ocultar paginaci√≥n cuando hay filtros activos
      const pagination = document.querySelector('.pagi-nav');
      if (pagination) {
        if (selectedColor || selectedSize || selectedPrice) {
          pagination.style.display = 'none';
        } else {
          pagination.style.display = 'flex';
        }
      }
      
      // Actualizar URL sin recargar p√°gina
      updateURL(selectedColor, selectedSize, selectedPrice);
      
      // Actualizar dropdowns despu√©s de aplicar filtros (para reflejar productos visibles)
      // Esto asegura que los dropdowns muestren solo opciones relevantes
      setTimeout(function() {
        updateFilterDropdowns();
      }, 100);
    }
    
    function updateURL(color, size, price) {
      const urlParams = new URLSearchParams();
      const params = [];
      
      if (color) params.push('color=' + encodeURIComponent(color));
      if (size) params.push('size=' + encodeURIComponent(size));
      if (price) params.push('price=' + encodeURIComponent(price));
      
      // Mantener sort_by si existe
      const currentParams = new URLSearchParams(window.location.search);
      if (currentParams.get('sort_by')) {
        params.push('sort_by=' + currentParams.get('sort_by'));
      }
      
      const newUrl = window.location.pathname + (params.length > 0 ? '?' + params.join('&') : '');
      window.history.replaceState({}, '', newUrl);
    }
    
    // Funci√≥n para resetear filtros
    function resetFilters() {
      const filterDropdowns = document.querySelectorAll('.filter-dropdown');
      filterDropdowns.forEach(function(dropdown) {
        if (dropdown.id !== 'filter-category') {
          dropdown.value = '';
        }
      });
      applyFilters();
    }
    
    // Exponer funci√≥n de reset globalmente si es necesario
    window.resetCollectionFilters = resetFilters;
  })();
</script>

